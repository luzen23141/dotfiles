#! /bin/zsh

source "$DOTFILES"/helperFunc/envHelper

# --- è¨­å®šå€ ---
# å»ºè­°å°‡ Key æ”¾åœ¨ç’°å¢ƒè®Šæ•¸ä¸­ (ä¾‹å¦‚ .zshrc æˆ– .bashrc: export GEMINI_API_KEY="ä½ çš„KEY")
# å¦‚æœæ²’æœ‰ç’°å¢ƒè®Šæ•¸ï¼Œå°±æœƒè®€å–ä¸‹é¢é€™è¡Œ
API_KEY="${GEMINI_API_KEY:-YOUR_HARDCODED_KEY_HERE}"
MODEL="${GEMINI_MODEL:-gemini-2.5-flash-lite}"
API_URL="https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent"
MAX_DIFF_LINES=50000

# --- æª¢æŸ¥ä¾è³´ ---
if [ -z "$API_KEY" ] || [ "$API_KEY" = "YOUR_HARDCODED_KEY_HERE" ]; then
    echo "âŒ éŒ¯èª¤: æœªè¨­å®š GEMINI_API_KEY"
    echo "è«‹è¨­å®šç’°å¢ƒè®Šæ•¸: export GEMINI_API_KEY='ä½ çš„Key'"
    exit 1
fi

if ! command -v jq &> /dev/null; then
    echo "âŒ éŒ¯èª¤: éœ€è¦å®‰è£ 'jq' ä¾†è™•ç† JSON"
    echo "Mac: brew install jq / Linux: sudo apt install jq"
    exit 1
fi

# --- å–å¾— Git Diff ---
# æª¢æŸ¥æ˜¯å¦æœ‰ staged çš„æª”æ¡ˆ
if ! git diff --cached --quiet; then
    # ä½¿ç”¨ --no-color ä¸¦ç§»é™¤ ANSI è½‰ç¾©åºåˆ—
    DIFF_CONTENT=$(git diff --cached --no-color | sed 's/\x1b\[[0-9;]*m//g' | tr -d '\r')
    DIFF_LINES=$(echo "$DIFF_CONTENT" | wc -l | tr -d ' ')
    
    if [ "$DIFF_LINES" -gt "$MAX_DIFF_LINES" ]; then
        echo "âš ï¸  è®Šæ›´éå¤§ ($DIFF_LINES è¡Œ)ï¼Œæ“·å–å‰ $MAX_DIFF_LINES è¡Œ..."
        DIFF_CONTENT=$(echo "$DIFF_CONTENT" | head -n "$MAX_DIFF_LINES")
    fi
else
    echo "âš ï¸  æ²’æœ‰ Staged çš„è®Šæ›´ (è«‹å…ˆ git add)"
    exit 0
fi

# --- æº–å‚™ Prompt ---
PROMPT="ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„ Git Commit Message æ’°å¯«å°ˆå®¶ã€‚è«‹åˆ†æä»¥ä¸‹ git diff ä¸¦ç”¢ç”Ÿä¸€å€‹ç²¾ç¢ºã€å°ˆæ¥­çš„ commit messageã€‚

**æ ¼å¼è¦æ±‚ï¼š**
- å¿…é ˆä½¿ç”¨ Conventional Commits è¦ç¯„
- æ ¼å¼ï¼š<type>: <description>
- Type é¸é …ï¼šfeat, fix, docs, style, refactor, perf, test, chore, build, ci
- Description ä½¿ç”¨ç¹é«”ä¸­æ–‡ï¼Œç°¡æ½”æ˜ç¢ºï¼ˆå»ºè­° 50 å­—ä»¥å…§ï¼‰

**æ’°å¯«åŸå‰‡ï¼š**
1. ç”¨å‹•è©é–‹é ­æè¿°ã€Œåšäº†ä»€éº¼ã€ï¼Œä¸æ˜¯ã€Œä»€éº¼è¢«åšäº†ã€
2. å¤šå€‹ç›¸é—œè®Šæ›´è¦ç¸½çµæ ¸å¿ƒç›®çš„ï¼Œä¸è¦åˆ—èˆ‰ç´°ç¯€
3. å°ˆæ³¨æ–¼ã€Œç‚ºä»€éº¼ã€è€Œéã€Œæ€éº¼åšã€
4. åªè¼¸å‡ºä¸€è¡Œ commit messageï¼Œä¸è¦æœ‰ä»»ä½•å…¶ä»–æ–‡å­—ã€è§£é‡‹æˆ– markdown æ¨™è¨˜

**ç¯„ä¾‹ï¼š**
- feat: æ–°å¢ä½¿ç”¨è€…ç™»å…¥åŠŸèƒ½
- fix: ä¿®æ­£è³‡æ–™åº«é€£ç·šé€¾æ™‚å•é¡Œ
- refactor: é‡æ§‹ API éŒ¯èª¤è™•ç†é‚è¼¯

Diff å…§å®¹ï¼š
"""


# --- å‘¼å« Gemini API ---
echo "ğŸ¤– æ­£åœ¨è«‹ Gemini ($MODEL) æ’°å¯« Commit Message..."

# ä½¿ç”¨ jq å»ºæ§‹ JSON Payload (ä½¿ç”¨ç®¡é“å’Œ slurp é¿å…æ§åˆ¶å­—ç¬¦å•é¡Œ)
TEMP_FILE=$(mktemp)
echo -n "$PROMPT" > "$TEMP_FILE"
echo -n "$DIFF_CONTENT" >> "$TEMP_FILE"
echo '' >> "$TEMP_FILE"
echo '"""' >> "$TEMP_FILE"
echo '' >> "$TEMP_FILE"
echo 'è«‹ç›´æ¥è¼¸å‡º commit messageï¼ˆä¸€è¡Œï¼Œç„¡å…¶ä»–å…§å®¹ï¼‰ï¼š' >> "$TEMP_FILE"

# ä½¿ç”¨ slurp å’Œ raw-input è®“ jq æ­£ç¢ºè™•ç†æ‰€æœ‰å­—ç¬¦
PROMPT_TEXT=$(cat "$TEMP_FILE" | jq -Rs .)
rm -f "$TEMP_FILE"

PAYLOAD=$(jq -n \
          --argjson text "$PROMPT_TEXT" \
          '{
            contents: [{ parts: [{ text: $text }] }],
            generationConfig: {
              temperature: 0.3,
              maxOutputTokens: 100,
              topP: 0.95
            }
          }')

RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$API_URL?key=$API_KEY" \
    -H "Content-Type: application/json" \
    -d "$PAYLOAD")

# åˆ†é›¢ HTTP ç‹€æ…‹ç¢¼å’Œå›æ‡‰å…§å®¹
HTTP_CODE=$(echo "$RESPONSE" | tail -n 1)
RESPONSE=$(echo "$RESPONSE" | sed '$d')

if [ "$HTTP_CODE" != "200" ]; then
    echo "âŒ API è«‹æ±‚å¤±æ•— (HTTP $HTTP_CODE)"
    echo "å›æ‡‰: $RESPONSE"
    exit 1
fi

# --- è§£æçµæœ ---
# æå–å›æ‡‰æ–‡å­—
COMMIT_MSG=$(printf '%s' "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // empty')

if [ -z "$COMMIT_MSG" ] || [ "$COMMIT_MSG" = "empty" ]; then
    echo "âŒ ç”Ÿæˆå¤±æ•—ã€‚API å›æ‡‰ï¼š"
    echo "$RESPONSE"
    exit 1
fi

# æ¸…ç†å¯èƒ½çš„ç©ºç™½å’Œ Markdown ç¬¦è™Ÿ
COMMIT_MSG=$(echo "$COMMIT_MSG" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | grep -v '^```' | sed -e 's/^`\{1,3\}//' -e 's/`\{1,3\}$//' | head -n 1)

# --- ç¹ç°¡è½‰æ› (æ ¹æ“šè¨­å®šæª”) ---
needT2c=$(get_env_value t2c "1")
if [ "$needT2c" = "0" ]; then
    echo "â„¹ï¸  t2c is 0. ä¿æŒç¹é«”ä¸­æ–‡ã€‚"
else
    if command -v opencc &> /dev/null; then
        echo "â„¹ï¸  t2c is not 0. è½‰æ›ç‚ºç°¡é«”ä¸­æ–‡..."
        echo "   (å¦‚ä¸æƒ³ç¿»è­¯ï¼Œè«‹åŸ·è¡Œ: a set t2c 0)"
        COMMIT_MSG=$(echo "$COMMIT_MSG" | opencc -c t2s.json)
    else
        echo "âš ï¸  æœªå®‰è£ openccï¼Œç„¡æ³•è½‰æ›ç‚ºç°¡é«”ã€‚ä¿æŒç¹é«”ä¸­æ–‡ã€‚"
        echo "   å®‰è£æ–¹å¼: brew install opencc"
    fi
fi

# --- ä½¿ç”¨è€…äº’å‹• ---
echo "--------------------------------------------------"
echo -e "ğŸ“ å»ºè­°è¨Šæ¯: \033[1;32m$COMMIT_MSG\033[0m"
echo "--------------------------------------------------"

# è®€å–ä½¿ç”¨è€…è¼¸å…¥ (Zsh ç‰ˆæœ¬)
read "CHOICE?åŸ·è¡Œ Commit? [y(Yes) / n(No) / e(Edit)]: "

case "$CHOICE" in
    y|Y )
        git commit -m "$COMMIT_MSG"
        ;;
    e|E )
        # è®“ä½¿ç”¨è€…ç·¨è¼¯
        if [ -n "$BASH_VERSION" ]; then
            read -e -p "è«‹ç·¨è¼¯è¨Šæ¯: " -i "$COMMIT_MSG" NEW_MSG
        else
            # Zsh ç‰ˆæœ¬ï¼šä½¿ç”¨ vared é€²è¡Œç·¨è¼¯
            NEW_MSG="$COMMIT_MSG"
            vared -p "è«‹ç·¨è¼¯è¨Šæ¯: " -c NEW_MSG
            [ -z "$NEW_MSG" ] && NEW_MSG="$COMMIT_MSG"
        fi
        git commit -m "$NEW_MSG"
        ;;
    * )
        echo "å·²å–æ¶ˆã€‚"
        ;;
esac
